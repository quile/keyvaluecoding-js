{"name":"Keyvaluecoding-js","body":"## Key-Value Coding\r\n\r\nOne of the greatest things about developing using the NeXT/Apple toolchain is the consistent use of something called key-value coding.  It's the kind of thing that, once you buy into its philosophy, will suddenly make a whole slew of things easier for you in ways that you never thought of before.  Every time I move to a new platform, be it Python or Javascript or Perl, I always find myself frustrated by its absence, and find myself jumping through all kinds of stupid hoops just to do things that would be dead-simple if key-value coding were available to me.\r\n\r\nSo here are a couple of Javascript implementations of KVC that you can glom onto your objects, or even glom onto everything in your system, and KVC will be available in all its glory (well, some of its glory... see below).  At present it's designed to work with node.js, but will probably work as-is with other commonJS systems like Narwhal.  I will work on getting it packaged up for use in a browser.\r\n\r\n(Note: there is an almost-identical Perl implementation of key-value coding [here](http://quile.github.com/keyvaluecoding-perl/).)\r\n\r\n### Installing\r\n\r\n```\r\nnpm install keyvaluecoding\r\n```\r\nor check the project out from [github](https://github.com/quile/keyvaluecoding-js) if you want the bleeding edge.\r\n\r\nThere are a number of different ways to use key-value coding.  For definitions of what \"complex\", \"simple\" and \"additions\" mean, see below.\r\n\r\nTo install _complex_ KVC implementation system-wide:\r\n(this is the recommended way to use it, but if you don't like things messing with\r\nyour universal object prototypes, you probably don't want this - however, this usage is\r\nmost similar to the use of the NSKeyValueCoding category in OSX/iOS)\r\n\r\n```\r\nrequire(\"keyvaluecoding\").install();\r\n```\r\n\r\nTo install the _simple_ KVC implementation system-wide:\r\n\r\n```\r\nrequire(\"keyvaluecoding\").install({ simple: true });\r\n```\r\n\r\nTo install the _complex_ implementation with _additions_, system-wide:\r\n\r\n```\r\nrequire(\"keyvaluecoding\").install({ additions: true });\r\n```\r\n\r\nTo install any of these implementations on any specific object:\r\n\r\n```\r\nvar thing = new Thing();\r\nrequire(\"keyvaluecoding\").install({ simple: true, target: thing });\r\n```\r\n\r\nIf you're going to use that style, you can save the return value\r\nfrom require() and use it:\r\n\r\n```\r\nvar thing = new Thing();\r\nvar kvc = require(\"keyvaluecoding\");\r\n...\r\nkvc.install({ simple: true, target: thing });\r\n```\r\n\r\nor use jQuery style wrapping:\r\n\r\n```\r\nvar thing = {};\r\nthing = kvc(thing);\r\n```\r\n\r\n\r\n### Usage\r\n\r\nAll implementations of KVC must support these methods:\r\n\r\n```\r\nvalueForKey( <key> )\r\nvalueForKeyPath( <keypath> )\r\nsetValueForKey( <value>, <key> )\r\nsetValueForKeyPath( <value>, <keypath> )\r\n```\r\n\r\nAt present there are only two implementations available, and they should be fine for your needs.\r\n\r\nOnce you have loading key-value coding and \"installed\" it into your runtime, any KVC-aware objects will now response to those methods.  ( Note: the difference between a key-path and a key is that a key-path can be an arbitrarily long dot-path of keys ).\r\n\r\nHere is an example session that should show how it works:\r\n\r\n```\r\n$ node\r\n> require('keyvaluecoding').install()\r\nundefined\r\n> var foo = { bar: \"This is foo.bar\",\r\n              baz: { quux: \"This is foo.baz.quux\", \r\n                     bonk: [ \"This is foo.baz.bonk.0\",\r\n                             \"and this foo.baz.bonk.1\" ]\r\n              }\r\n            };\r\nundefined\r\n> foo\r\n{ bar: 'This is foo.bar',\r\n  baz: \r\n   { quux: 'This is foo.baz.quux',\r\n     bonk: \r\n      [ 'This is foo.baz.bonk.0',\r\n        'and this foo.baz.bonk.1' ] } }\r\n> foo.valueForKey(\"bar\")\r\n'This is foo.bar'\r\n> foo.valueForKeyPath(\"baz.quux\")\r\n'This is foo.baz.quux'\r\n> foo.valueForKeyPath(\"baz.bonk.1\")\r\n'and this foo.baz.bonk.1'\r\n> \r\n```\r\n\r\nIf you use the (default) _complex_ implementation, valueForKey( <key> ) will also work for key paths, so you will never really need to use valueForKeyPath( <keypath> ):\r\n\r\n```\r\n> foo.valueForKey(\"baz.bonk.0\")\r\n'This is foo.baz.bonk.0'\r\n> \r\n```\r\n\r\nIf a function is found rather than a property, it will be called in the context of the object it belongs to:\r\n\r\n```\r\n> foo.bing = function() {\r\n    return [ \"This is foo.bing.0\", \"This is foo.bing.1\" ]\r\n}\r\n[Function]\r\n> foo\r\n{ bar: 'This is foo.bar',\r\n  baz: \r\n   { quux: 'This is foo.baz.quux',\r\n     bonk: \r\n      [ 'This is foo.baz.bonk.0',\r\n        'and this foo.baz.bonk.1' ] },\r\n  bing: [Function] }\r\n> foo.valueForKey(\"bing.0\")\r\n'This is foo.bing.0'\r\n> \r\n```\r\n\r\nThe _complex_ implementation allows nested key-paths, which are turned into arguments:\r\n\r\n```\r\n> foo.bong = function( bung ) { return bung.toUpperCase(); }\r\n[Function]\r\n> foo.bong(\"hey\")\r\n'HEY'\r\n> foo.valueForKey(\"bong(baz.quux)\")\r\n'THIS IS FOO.BAZ.QUUX'\r\n> var goo = { something: function() { return foo }, name: \"I'm called goo\" };\r\nundefined\r\n> goo\r\n{ something: [Function],\r\n  name: 'I\\'m called goo' }\r\n> goo.valueForKey(\"something.bong(name)\")\r\n'I\\'M CALLED GOO'\r\n> \r\n```\r\n\r\nThe corresponding _set_ methods, _setValueForKey_ and _setValueForKeyPath_ will set the value on whatever object the key/keypath resolves to.  If any part of the key or keypath returns *null*, the call will (at present) fail silently.  *NOTE:* This is not the same behaviour as Apple's NSKeyValueCoding; it's a bit more like the Clojure \"thread\" operator (->>).\r\n\r\n\r\n### Additions\r\n\r\nWhat are these \"additions\"?  They're only available with the _complex_ implementation of KVC, and they provide a number of \"special\" methods that can be used in keypaths:\r\n\r\n* eq(a, b)\r\n* not( a )\r\n* and( a, b )\r\n* or( a, b )\r\n* commaSeparatedList( a )\r\n* truncateStringToLength( a, l )\r\n* sorted( a )\r\n* reversed( a )\r\n* keys( a )\r\n* length( a )\r\n* int( a )\r\n\r\nFor example:\r\n\r\n```\r\n$ node\r\n> require('keyvaluecoding').install({ additions: true });\r\nundefined\r\n> var foo = { a: true, b: false, c: false };\r\nundefined\r\n> foo.valueForKey(\"and(a, b)\")\r\nfalse\r\n> foo.valueForKey(\"or(a, b)\")\r\ntrue\r\n> foo.valueForKey(\"or(b, c)\")\r\nfalse\r\n```\r\n\r\nNote that the arguments can be arbitrarily long key-paths.\r\n\r\n### See Also\r\n\r\n[Nearly identical Perl implementation of key-value coding](http://quile.github.com/keyvaluecoding-perl/)","tagline":"Javascript Implementation of KVC","google":"UA-30714478-1","note":"Don't delete this file! It's used internally to help with page regeneration."}